## 内存管理

### 内存引用计数
引用计数,是一种内存管理方式,主要进行管理,内存的回收释放
对于内存管理方式,大体可以分为两种

* 标记回收管理
* 引用计数管理

iOS中主要使用引用计数的方式进行内存管理

* 当我需要一个对象时,编译器会申请一块内存,去存储这个对象,并且为对象的引用计数＋1
* 当别人也需要使用这个对象的时候,对该对象的引用计数再+1
* 当我不需要这个对象的时候,该对象的引用计数-1
* 当别人也不需要这个对象的时候,对该对象的引用计数再-1
* 编译器判断对象的引用计数为0时,当前的对象被释放,存储对象的内存,会被系统回收

iOS代码编写时,引用计数是如何变化的

```
// 生成的对象的引用计数+1
id obj = [[NSObject alloc] init]
id obja = [NSObject new]

// MRC 手动引用计数+1
[obj retain]

```
关于 alloc 方法,在 alloc 的内部,调用的是 allocWithZone 使用方法,可以避免产生内存碎片

```
allocWithZone 方法会判断需要分配的内存空间的大小.
将需要大的内存的对象,放置在大内存区域.
而只需要小的内存的对象,放置在小的内存区域.
减少内存之前的空隙,避免出现内存碎片
```

一些内存管理的方法(MRC)

* retain 引用计数+1
* release 引用计数-1
* autorelease 将对象放置路autoreleasePool中去管理,当执行到autoReleasePool之外是,对象释放

### autorelease

```
{
	int a
}
// 当变量的作用域结束时,内存将会释放
```
当对对象进行了 autorelease 操作之后,对象的内存生命周期将会放置到autoReleasePool中,随着autoReleasePool的结束,进行自动释放
oc中的mian函数,就有管理程序中的autorelease变量的autoReleasePool,由NSRunLoop去管理,当处理图片的时候可以借用autoReleasePool去进行一些图片内存的释放

### ARC 与 MRC
ARC 自动垃圾回收机制,本质上还是使用引用计数的方式进行内存管理,只是系统会自动判断,变量是否需要引用计数的变化
#### 变量修饰符
对于 ARC 而言系统引入了变量修饰符,来帮助developer标记对象,从而帮助系统管理对象的引用计数

* strong

```
也是在 ARC 中默认的变量修饰符 表示:强引用
{
	id obj = [NSObject new]
}
// 在作用域内,引用计数＋1
// 当超出作用域后,obj对象对内存的持有-1
// 该内存上的引用计数之前为1,现在变为0,该内存被系统回收
// 如果内存还被比如另外的指针锁应用,则引用计数不为0,内存不会释放

//注意: 
//(作用域是对对象而言,对象是指针,指向内存地址,地址中存放着数据和引用计数的情况
是否系统回收,仅仅关联于引用计数的情况)
```
* weak

```
表示: 弱应用

对象对内存的引用计数不会造成变化
主要解决循环应用问题,例如对象a中的b变量,持有对象b; 而对象b中的a变量,持有对象a
当a需要释放的时候,需要先释放b,当b要释放的时候,需要先时候a,所以造成循环引用,所以需要弱引用

注意: weak修饰的对象,因为不对内存进行引用计数+1的处理,
所以当内存被释放的时候,weak修饰的对象变为nil,因为oc中对nil发送消息是没有问题的
```

* unsafe_unretaion

```
与weak相同,都是弱引用,但是unsafe_unretaion 对象被释放之后,并不会和weak一样被赋值为nil
所以是不安全的
```

* copy

```
与strong类似都是会进行引用计数+1,但是不同的是,copy会重新开辟一块内存,类似深拷贝的逻辑
常见于 NSString 变量的修饰

如果使用strong修饰NSString,
若把nsmutableString赋值给这个NSString变量,本质是多了一个指针指向了 这个NSSMutableString的内存,
所以当NSMutableString,进行了修改之后,由于NSString的指针也是指向这个地址的,所以NSString的值也会变,
为了不让修改前变量,导致NSString也发生改变的情况出现,采用copy的方式修饰变量,这样会出现快内存,修改nsmutablestring不会让NSString也变化
```

### 内存的分配

内存分为五大区域

* 栈区（ stack ）

```
由编译器自动分配释放 
存放函数的参数值，局部变量的值等。
效率很高，但是分配的内存容量有限.
```
* 堆区（ heap ）

```
也叫动态内存分配.
程序在运行的时候用alloc或new申请任意大小的内存 
程序员自己负责在适当的时候释放内存。
动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存.
注意它与数据结构中的堆是两回事，分配方式倒是类似于链表.
```
* 全局区（静态区）（ static )

``` 
全局变量和静态变量的存储是放在一块的，
初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。
程序结束后由有系统释放.
```
* 常量区 

```
常量字符串就是放在这里的.程序结束后由系统释放
```
* 程序代码区 

```
存放函数体的二进制代码.
```


### weak 和 unowned
在Swift对弱引用的表述

```
class B:NSObject {
    var b:String = "abc"
}
class A:NSObject {
    weak var weakB:B? 
    unowned var unownedB:B = B.init();
    var testValue:String = "abc"
}

// 注意
// MARK: 因为 weak 修饰的变量是在引用计数为0是赋值为nil,
//       所以在Swift中必须要以可选形的方式去处理,反向的诞生了unowned修饰符
```
因为在Swift出现了可选形,所以可选形的变量就会被表述,是Option<warp>的枚举

```
//swift:
enum Option(warp)
{
	case: some(warp)
	case: none
}
```
